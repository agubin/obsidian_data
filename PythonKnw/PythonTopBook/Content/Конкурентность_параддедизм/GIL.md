1. Каждый экземпляр интерпретатора Python является процессом. Дополнительные процессы Python можно запускать с помощью библиотек multiprocessing или concurrent.futures. Библиотека subprocess предназначена для запуска процессов, в которых будут исполняться внешние программы, написанные на любом языке. 
2. Интерпретатор Python использует единственный поток, в котором выполняется и  пользовательская программа, и  сборщик мусора. Для запуска дополнительных потоков предназначены библиотеки threading и concurrent.futures. 
3. Доступ к счетчикам ссылок на объекты и другим внутренним структурам интерпретатора контролируется глобальной блокировкой интерпретатора (Global Interpreter Lock – GIL). Только один поток Python может удерживать GIL в каждый момент времени. Это означает, что только один поток может выполнять Python-код, и от числа процессорных ядер это не зависит.
4. Чтобы помешать потоку Python удерживать GIL бесконечно, интерпретатор байт-кода Python периодически (по умолчанию раз в 5 миллисекунд1 ) приостанавливает текущий поток и тем самым освобождает GIL. Поток может попытаться снова захватить GIL, но если его ждут другие потоки, то планировщик ОС, возможно, выберет один из них. 
5. Программист, пишущий на Python, не  может управлять GIL. Но  встроенная функция или расширение, написанное на C или на любом другом языке, имеющем интерфейс к Python на уровне C API, может освободить GIL во время выполнения длительной задачи. 
6. Любая стандартная библиотечная функция Python, делающая системный вызов2 , освобождает GIL. Сюда относятся все функции, выполняющие дисковый ввод-вывод, сетевой ввод-вывод, а  также time.sleep(). Многие счетные функции в библиотеках NumPy/SciPy, а также функции сжатия и распаковки из модулей zlib и bz2 также освобождают GIL3 . 
7. Расширения, интегрированные на уровне интерфейса между Python и C, могут тоже запускать потоки, не управляемые Python, на которые действие GIL не распространяется. Такие свободные от GIL потоки в общем случае не могут изменять объекты Python, но могут читать и записывать память объектов, поддерживающих протокол буфера, например bytearray, array.array и массивы NumPy. 
8. Влияние GIL на сетевое программирование с помощью потоков Python сравнительно невелико, потому что функции ввода-вывода освобождают GIL, а чтение или запись в сеть всегда подразумевает высокую задержку по сравнению с чтением-записью в память. Следовательно, каждый отдельный поток все равно тратит много времени на ожидание, так что их выполнение можно чередовать без заметного снижения общей пропускной способности. Потому-то Дэвид Бизли и говорил: «Python отлично умеет ничего не делать»4 . 
9. Состязание за GIL замедляет работу счетных потоков в Python. В таких случаях последовательный однопоточный код проще и быстрее. 
10. Для выполнения счетного Python-кода на нескольких ядрах нужно использовать несколько процессов Python.

