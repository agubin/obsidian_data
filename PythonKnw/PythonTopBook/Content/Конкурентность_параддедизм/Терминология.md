**Конкурентность** 
Способность обрабатывать несколько задач, чередуя выполнение или параллельно (если это возможно), так что каждая задача в  конечном итоге успешно доходит до конца или завершается с ошибкой. Одноядерный процессор допускает конкурентность, если работает под управлением планировщика ОС, который чередует выполнение ожидающих задач. Встречается также название многозадачность.

**Параллелизм** 
Способность выполнять несколько вычислений одновременно. Для этого необходим многоядерный процессор, несколько процессоров, графический процессор (GPU) или кластер из нескольких компьютеров.

**Единица выполнения** 
Общий термин для объектов, выполняющих код конкурентно, каждый из которых имеет независимые от других состояния и стек вызовов. Python поддерживает три вида единиц выполнения: процессы, потоки и сопрограммы.

**Процесс** 
Экземпляр компьютерной программы во время ее выполнения, которому выделены память и квант процессорного времени. Современные операционные системы для настольных компьютеров без труда управляют 648  Модели конкурентности в Python сотнями конкурентных процессов, при этом каждый процесс изолирован в  собственном адресном пространстве. Процессы взаимодействуют посредством каналов, сокетов или отображенных на память файлов – все они могут передавать только «голые» байты. Чтобы передать объект Python из одного процесса в другой, его необходимо сериализовать в виде последовательности байтов. Это дорого, и  не все объекты допускают сериализацию. Процесс может порождать подпроцессы, или дочерние процессы. Они изолированы как друг от друга, так и от родительского процесса. Процессы допускают вытесняющую многозадачность: планировщик ОС периодически вытесняет, т. е. приостанавливает, работающий процесс, чтобы дать возможность поработать остальным. Это означает, что зависший процесс не может подвесить всю систему – теоретически.

**Поток** 
Единица выполнения внутри одного процесса. Сразу после запуска процесс содержит один – главный – поток. Вызывая системные API, процесс может создавать дополнительные потоки, которые будут работать конкурентно. Потоки внутри одного процесса разделяют общее пространство памяти, в которой находятся активные объекты Python. Это позволяет потокам совместно использовать данные, но может приводить к повреждению данных, если сразу несколько потоков пытаются обновить один и тот же объект. Как и процессы, потоки допускают вытесняющую многозадачность под управлением планировщика ОС. Поток потребляет меньше ресурсов, чем процесс, для выполнения одной и той же работы.

**Сопрограмма** 
Функция, которая может приостановить свое выполнение и  продолжить позже. В Python классические сопрограммы строятся на основе генераторных функций, а платформенные определяются с помощью ключевых слов async def.В разделе «Классические сопрограммы» главы 17 это понятие было определено, а в главе 21 будет рассмотрено использование платформенных сопрограмм. В Python сопрограммы обычно исполняются в одном потоке под управлением цикла событий, который работает в том же потоке. Такие каркасы асинхронного программирования, как asyncio, Curio или Trio, предоставляют цикл событий и поддерживающие библиотеки для реализации неблокирующего ввода-вывода на основе сопрограмм. Сопрограммы поддерживают кооперативную многозадачность: каждая сопрограмма должна явно уступать процессор с помощью ключевого слова yield или await, чтобы другие части программы могли работать конкурентно (но не параллельно). Это означает, что любой блокирующий код внутри сопрограммы блокирует выполнение цикла событий и всех остальных сопрограмм – в отличие от вытесняющей многозадачности, которую поддерживают процессы и потоки. С другой стороны, сопрограммы потребляют меньше ресурсов по сравнению с процессами и потоками, выполняющими ту же работу.

**Очередь** 
Структура данных, позволяющая помещать и извлекать элементы, обычно в порядке FIFO: первым пришел, первым ушел. Очереди дают возможность  единицам выполнения обмениваться данными и управляющими сообщениями, например кодами ошибок и  сигналами завершения. Реализация очереди зависит от модели конкурентности: пакет queue в стандартной библиотеке Python предоставляет классы очередей для поддержки потоков, тогда как пакеты multiprocessing и  asyncio реализуют собственные классы очередей. Пакеты queue и asyncio включают также очереди, обслуживаемые не в порядке FIFO: LifoQueue и PriorityQueue.

**Блокировка** 
Объект, который единицы выполнения могут использовать для синхронизации своих действий, чтобы избежать повреждения данных. Во время обновления разделяемой структуры данных исполняемый код должен удерживать ассоциированную блокировку. Это служит для остальных частей программы сигналом, что нужно подождать, пока блокировка освободится, и только потом обращаться к той же структуре данных. Простейший вид блокировки называется мьютексом (mutual exclusion – взаимное исключение). Реализация блокировки зависит от модели конкурентности.

**Состязание** 
Спор за ограниченный ресурс. Состязание возникает, когда несколько единиц выполнения пытаются обратиться к разделяемому ресурсу, например блокировке или хранилищу. Бывает также состязание за процессор, когда счетные процессы или потоки должны ждать, пока планировщик ОС выделит им долю процессорного времени.