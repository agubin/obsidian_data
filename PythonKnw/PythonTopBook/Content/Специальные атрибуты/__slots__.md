Определяет иной способ хранения атрибутов класса и их значений

атрибуты с именами, представленными в \_\_slots__, хранятся в скрытом массиве ссылок, потребляющем намного меньше памяти, чем \_\_dict\_\_.
![[Pasted image 20240218115258.png]]

В оригинальном классе \_\_slots__ заменяет \_\_dict__. У наследниках есть как \_\_slots__ так и \_\_dict__.
![[Pasted image 20240218115414.png]]
Чтобы гарантировать отсутствие \_\_dict__ в подклассе, необходимо еще раз объявить в нем __slots__. Если объявить \_\_slots__ = () (пустой кортеж), то у  экземпляров подкласса не  будет \_\_dict__ и  они будут принимать только атрибуты, перечисленные в атрибуте \_\_slots__ базового класса

Атрибуты \_\_slots__ суперклассов добавляются в  \_\_slots__ текущего класса

Можно и «память сэкономить, и косточкой не подавиться»: если добавить имя '\_\_dict__' в список \_\_slots__, то все атрибуты, перечисленные в \_\_slots__, будут храниться в массиве ссылок, принадлежащем экземпляру, но при этом разрешено динамически создавать новые атрибуты, которые хранятся в словаре \_\_dict__, как обычно.

==Разумеется, помещение '\_\_dict__' в атрибут \_\_slots__ может свести на нет все преимущества последнего, но это зависит от количества статических и динамических атрибутов и того, как они используются. Бездумная оптимизация еще хуже преждевременной: вы увеличиваете сложность, а взамен не получаете ничего.==

==Для классов, где используется \_\_slots__, нельзя употреблять декоратор @cached_property, если только в\_\_slots__ явно не включено имя '\_\_dict__'.==