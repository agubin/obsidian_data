И math.fsum, и replacer.zip_replace должны обойти все аргументы, порождаемые Iterable, чтобы вернуть результат. Учитывая, что бывают бесконечные итерируемые объекты, например генератор itertools.cycle, эти функции могли бы потребить всю память, что приведет к  аварийному завершению процесса. Несмотря на эту потенциальную опасность, в современном Python довольно часто встречаются функции, которые принимают на входе Iterable даже тогда, когда для получения результата необходимо обработать его целиком. Это дает вызывающей стороне возможность поставлять входные данные с  помощью генератора, а не строить последовательность заранее. Если количество входных элементов велико, то так можно сэкономить много памяти.