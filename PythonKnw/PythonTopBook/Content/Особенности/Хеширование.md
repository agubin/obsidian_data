Объект называется хешируемым, если имеет хеш-код, который не изменяется на протяжении всего времени его жизни (у него должен быть метод __hash__()), и допускает сравнение с другими объектами (у него долСтандартный API типов отображений  105 жен быть метод __eq__()). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны

Все числовые типы и плоские неизменяемые типы str и bytes являются хешируемыми. Объект типа frozenset всегда хешируемый, потому что его элементы должны быть хешируемыми по определению. Объект типа tuple является хешируемым только тогда, которые хешируемы все его элементы

Любой пользовательский тип является хешируемым по определению, потому что его хеш-значение равно id(), а метод __eq__(), унаследованный от класса object, просто сравнивает идентификаторы объектов. Если объект реализует пользовательский метод __eq__(), учитывающий внутреннее состояние, то он будет хешируемым, только если его метод __hash__() всегда возвращает один и тот же хеш-код. На  практике это требование означает, что методы __eq__() и __hash__() должны принимать во внимание только те атрибуты экземпляра, которые не изменяются на протяжении всей жизни объекта.

Хешировать можно только неизменяемые объекты. Только они могут быть ключами словарей или элементами Set
На основе этого можно сделать проверку на изменяемость:

`def fixed(o):` 
	`try:`
		`hash(o)`
	`except TypeError:` 
		`return False`
	`return True`
